This set of codes requires Crocker & Grier particle tracking code found here: 
https://site.physics.georgetown.edu/matlab/, and export_fig from the MATLAB Fileshare found here: 
https://www.mathworks.com/matlabcentral/fileexchange/23629-export_fig, as well as the MATLAB Signal Processing Toolbox.

The tracking code does not necessarily re-assign the same cell ID to the same cell each time it is run, due to the nature of the way the Crocker and Grier code is written. Because of this, different sample data is provided for some of the different steps here. This is because the manually-sorted data is not necessarily going to have the same cells with the same ID when the user runs the sample data. 

The post-impact input files for this code should be in RGB format .tif files. ImageJ or Fiji can be used to convert from other image formats. Ensure that the colors are in the correct channels (for example, Slidebook likes to swap R and B). The impact input file should be an 8-bit .tif file. 

For cells that are not moving, the video can be registered onto the first frame. This will allow the user to connect tracking between the impact and post-impact videos (and only works at the impact site). MATLAB's fitgeotrans and imwarp functions are used to accomplish this. An example snippet of code is provided, but this is not used in the final data analysis so is not integrated into the code as a whole.

To run the codes provided, ensure that the MATLAB directory includes all files within the folder. Start with all\_tracking\_function\_calls. This code will require the user to fill in the various parameters associated with the timing of the images, where the images are saved, alongside the positions that the user wishes to track. Impact and post-impact tracking parameters for the Crocker and Grier algorithm must be filled in, with example values saved within the code itself. Feature extraction parameters should also be filled in (for detailed explanation see the code). Once all parameters are filled, the code can be run. Input parameters for each of the called functions can be found in the functions. Most of the functions require a folder and date to designate where the images are stored and where the output files should be sent to. TrackImpact, TrackPostImpact, and FeatureExtraction have print parameters, which can be set to `on' or `off' to determine whether or not the tracking images or feature extraction images are printed. These images are used to help optimize the parameters for tracking or feature extraction. The first time the code is run, the should be set to `on' in order to ensure that the tracking is working correctly, and that the peak detection looks correct. Future iterations of the code with optimal parameters do not require printing the images. The code takes significantly longer to run if printing all images, but will be faster on a computer with a better GPU (MATLAB renders faster).

Once all_tracking_function_calls is run, the tracking and feature extraction is complete. The user is given a choice between the sorting_function_calls_manual and 
sorting_function_calls_nomanual codes. For the first time running the data, the user should use the GUI (detailed below) to identify the categories of all of the cells. These categories are then used to label and sort all of the cells. Sorting can be easily accomplished by creating a copy of all intensity curves, then using the first section of sorting_function_calls_manual to make folders corresponding to all of the input categories. ManualDataCompilation will then scrape filenames from within each of these folders to add them to a structure with the correct labels. From here, both of the sorting codes will run CellAttributes to organize features for each time series and DecisionTree to categorize them, finally using SplitPeaksDataCompilation to format the data into shape for time series classification.

The decision tree was custom programmed for our system. After CellAttributes is run in the main script, the features are used to categorize cells into their respective categories. The parameters of the tree must be changed for each new system, with the overall structure remaining quite similar. For other systems, new categories may be identified, and used to determine the if-else statements building the tree.

Example data for this code can be found here:
